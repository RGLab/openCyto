#' Applies gatingTemplate to one GatingSet.
#'
#' It loads the gating methods by topological order and applies them to \code{GatingSet}.
#'
#' @param x a \code{gatingTemplate} object
#' @param y a \code{GatingSet} object
#' @param env_fct a \code{environment} that contains \code{fcTree} object named as 'fct'. If NULL (by default), no \code{fcTree} will be constructed. It is currently reserved for the internal debugging.
#' @param ... 
#'  \itemize{
#'      \item{start}{ a \code{character} that specifies the population (correspoding to 'alias' column in csv template) where the gating prcoess will start from. It is useful to quickly skip some gates and go directly to the target population in the testing run. Default is "root".}
#'      \item{stop.at}{ a \code{character} that specifies the population (correspoding to 'alias' column in csv template) where the gating prcoess will stop at. Default is NULL, indicating the end of gating tree.}
#'      \item{mc.cores}{ passed to \code{multicore} package for parallel computing}
#'      \item{parallel_type}{  \code{character} specifying the parallel type. The valid options are "none", "multicore", "cluster".}
#'      \item{cl}{ \code{cluster} object passed to \code{parallel} package (when \code{parallel_type} is "cluster")}
#'  }  
#' 
#' 
#' @return 
#' Nothing. As the side effect, gates generated by gating methods are saved in \code{GatingSet}. 
#' @examples
#' \dontrun{
#'  gt <- gatingTemplate(file.path(path, "data/ICStemplate.csv"), "ICS")
#'  gs <- GatingSet(fs) #fs is a flowSet/ncdfFlowSet
#'  gating(gt, gs)
#'  gating(gt, gs, stop.at = "v") #proceed the gating until population 'v'
#'  gating(gt, gs, start = "v") # start from 'v'
#'  gating(gt, gs, parallel_type = "multicore", mc.cores = 8) #parallel gating using multicore
#'  #parallel gating by using cluster
#'  cl1 <- makeCluster (8, type = "MPI")
#'  gating(gt, gs, parallel_type = "cluster", cl = cl1)
#'  stopCluster ( cl1 )
#' }
#' @rdname gating-methods
#' @export
setGeneric("gating", function(x, y, ...) standardGeneric("gating"))

#' @aliases 
#' gating,gatingTemplate,GatingSet-method
#' @rdname gating-methods
setMethod("gating", signature = c("gatingTemplate", "GatingSet"),
    definition = function(x, y, env_fct = NULL, ...) {
      .gating_gatingTemplate(x,y,env_fct,...)
    })

#' @aliases 
#' gating,gatingTemplate,GatingSetList-method
#' @rdname gating-methods
setMethod("gating", signature = c("gatingTemplate", "GatingSetList"),
    definition = function(x, y, env_fct = NULL, ...) {
      .gating_gatingTemplate(x,y,env_fct,...)
    })
#' internal function (gating_gatingTemplate)
#'  
#' @param stop.at a \code{character} that specifies the population (correspoding to 'alias' column in csv template) where the gating prcoess will stop at.
#' @param start a \code{character} that specifies the population (correspoding to 'alias' column in csv template) where the gating prcoess will start from. It is useful to quickly skip some gates and go directly to the target population in the testing run. 
#' @param ... other arguments passed to the gatingMethod-specific \code{gating} methods.
#' @importFrom RBGL tsort
#' @importFrom plyr ldply
.gating_gatingTemplate <- function(x, y, env_fct = NULL, start = "root", stop.at = NULL, ...) {
  gt <- x
  if (!is.null(env_fct)) {
    # use the fcTree if already exists
    if (exists("fct", env_fct)) {
      fct <- get("fct", env_fct)
    } else {
      # create one from gt if not
      fct <- fcTree(gt)
      assign("fct", fct, env_fct)
    }
    
  }
    #validity check for stop.at argument
  if(!is.null(stop.at)){
    if(is.na(match(stop.at,sapply(getNodes(gt),alias))))
      stop("Can't find stop point: ", stop.at)
  }
  # gate each node 
  gt_nodes <- tsort(gt)[-1]#by the topological order

  #try to skip some nodes to save time
  if(start != "root"){
    startID <- match(start, basename(gt_nodes))
    if(length(startID) > 1)
      stop("multiple nodes matched to 'start': ", start)
    if(length(startID) == 0)
      stop("No node matched to 'start': ", start)
    gt_nodes <- gt_nodes[startID:length(gt_nodes)]
  }  
    
                   
  for (node in gt_nodes) {
    
    # get parent node to gate
    gt_node_pop <- getNodes(gt, node)
    if(!is.null(stop.at)){
    
      if(alias(gt_node_pop) == stop.at)
      {
        message("stop at: ",stop.at)
        break
      }
        
    }
    
    parent <- getParent(gt, node)
    
    # extract gate method from one edge(since multiple edge to the same node is
    # redudant)
    this_gate <- getGate(gt, parent, node)
    
    
    
    #get preprocessing method
    this_ppm <- ppMethod(gt, parent, node)
    
    parentInd <- match(parent, getNodes(y[[1]], showHidden = TRUE))
    if (is.na(parentInd)) 
      stop("parent node '", parent, "' not gated yet!")
    
    #preprocessing
    pp_res <- NULL
#    browser()
    if(class(this_ppm) == "ppMethod")
      pp_res <- preprocessing(x = this_ppm, y, parent = parent, gtPop = gt_node_pop, gm = this_gate, ...)
#    browser()
    # pass the pops and gate to gating routine
    filterObj <- gating(x = this_gate, y, parent = parent, gtPop = gt_node_pop, pp_res = pp_res, ...)
    # update fct
    if (!is.null(env_fct) && !is.null(filterObj)) {
      nodeData(env_fct$fct, node, "fList")[[1]] <- filterObj
    }  
    
    
  }
  message("finished.")
}


#' apply a \link[openCyto:gtMethod-class]{gtMethod} to the \code{GatingSet}
#' 
#' 
#' @inheritParams .gating_gtMethod
#' @param ... other arguments
#' @aliases
#' gating,gtMethod,GatingSet-method 
#' gating,gtMethod,GatingSetList-method
setMethod("gating", signature = c("gtMethod", "GatingSet"),
    definition = function(x, y, ...) {
      .gating_gtMethod(x,y,...)
    })
setMethod("gating", signature = c("gtMethod", "GatingSetList"),
    definition = function(x, y, ...) {
      .gating_gtMethod(x,y,...)
    })
#' internal function (gating_gtMethod)
#' 
#' It is a generic gating function that does:
#' 1. parse the gating parameters
#' 2. group the data when applicable 
#' 3. apply parallelism when applicable  
#' 4. pass the flow data(maybe grouped) and preprocessing results to the adaptor function ".gating_wrapper"
#' 5. collect the gates and add to GatingSet object
#' 
#' 
#'  @param x \code{gtMethod}
#'  @param y \code{GatingSet}
#'  @param gtPop a \code{gtPopulation} object that contains the information of the cell population that is going to be generated by this gating method.
#'  @param  parent \code{character} specifying the parent node within \code{GatingSet} to which the new popoulation is to be attached.
#'  @param  pp_res \code{list} the preprocessing results to be used by the gating method. The names of the list has to be matched to the sample names of the data.
#'  @param  mc.cores passed to \code{multicore} package for parallel computing
#'  @param  parallel_type \code{character} specifying the parallel type. The valid options are "none", "multicore", "cluster".
#'  @param  cl \code{cluster} object passed to \code{parallel} package
#'  @param  plot \code{logical} whether to plot the gates after the gating is done
#'  @param  xbin \code{numeric} passed to \link[flowViz:xyplot]{xyplot}
#'  @import flowWorkspace
.gating_gtMethod <- function(x, y, gtPop, parent, pp_res 
            , mc.cores = 1, parallel_type = c("none", "multicore", "cluster"), cl = NULL
            , plot = FALSE, xbin = 128,  ...) {
  
  require("parallel")
#  browser()
  args <- parameters(x)

  # HOTFIX: This resolve an error when args is a named list with name NA and object NA.
  # The resulting error occurs down below and is:
  # Error in thisCall[[arg]] <- args[[arg]] : subscript out of bounds
  if (!is.null(names(args))) {
    args <- args[!is.na(names(args))]
  }
    
  gm <- paste0(".", names(x))
  
  dims <- dims(x)
  xChannel <- unname(dims["xChannel"])
  yChannel <- unname(dims["yChannel"])
  is_1d_gate <- any(is.na(dims))
  
  popAlias <- alias(gtPop)
  popName <- names(gtPop)
  popId <- gtPop@id
  gs_nodes <- basename(getChildren(y[[1]], parent))
  
  if (length(gs_nodes) == 0)
    isGated <- FALSE
  else
    isGated <- any(popAlias %in% gs_nodes)
    
  if(!isGated)
  {
    message("Gating for '", popAlias, "'")
    
    parent_data <- getData(y, parent)
    parallel_type <- match.arg(parallel_type)
    ## get the accurate channel name by matching to the fr
    if (!is.na(xChannel)) {
      xParam <- getChannelMarker(parent_data[[1]], xChannel)
      xChannel <- as.character(xParam$name)
    }
    yParam <- getChannelMarker(parent_data[[1]], yChannel)
    yChannel <- as.character(yParam$name)

    channels <- c(xChannel, yChannel)
    # Splits the flow set into a list.
    # By default, each element in the list is a flowSet containg one flow frame,
    # corresponding to the invidual sample names.
    # If 'split' is given, we split using the unique combinations within pData.
    # In this case 'split' is specified with column names of the pData.
    # For example, "PTID:VISITNO"
    # when split is numeric, do the grouping by every N samples
    groupBy <- groupBy(x)
    if (groupBy != "" && x@collapse) { #when x@collapse == FALSE,then ignore groupBy argument since grouping is only used for collapsed gating
      
      split_by <- as.character(groupBy)
      split_by_num <- as.numeric(split_by)
      #split by every N samples
      if(!is.na(split_by_num)){
            nSamples <- length(parent_data)
            if(nSamples==1){
              split_by <- 1
            }else{
              split_by <-  sample(rep(1:nSamples, each = split_by_num, length.out= nSamples))  
            }
            
      }else{
        #split by study variables
        split_by <- strsplit(split_by, ":")[[1]]
        split_by <- apply(pData(parent_data)[, split_by, drop = FALSE], 1, paste, collapse = ":")
        split_by <- as.character(split_by)
      }
    } else {
      split_by <- sampleNames(parent_data)
    }

    fslist <- split(parent_data, split_by)
    
    if(is.null(pp_res))
      pp_res <- sapply(names(fslist),function(i)pp_res)
    else
      pp_res <- pp_res[names(fslist)] #reorder pp_res to make sure it is consistent with fslist
    # construct method call
    thisCall <- substitute(f1(fslist,pp_res))
    thisCall[["FUN"]] <- as.symbol(".gating_wrapper")
    args[["gFunc"]] <- gm  #set gating method
    args[["popAlias"]] <- popAlias  
    args[["channels"]] <- channels #to deprecate x,y channel
    args[["xChannel"]] <- xChannel  #set x,y channel
    args[["yChannel"]] <- yChannel
    
    if (is_1d_gate) {
      if (grepl("-$", popName)) {
        positive <- FALSE
      } else if (grepl("\\+$", popName)) {
        positive <- TRUE
      } else {
        stop("Invalid population name! Name should end with '+' or '-' symbol.")
      }
      
      args[["positive"]] <- positive
    }

    
    thisCall[["MoreArgs"]] <- args
    
    ## choose serial or parallel mode
    
      
    if (parallel_type == "multicore") {
      message("Running in parallel mode with ", mc.cores, " cores.")
      thisCall[[1]] <- quote(mcmapply)
      thisCall[["mc.cores"]] <- mc.cores
    }else if(parallel_type == "cluster"){
      if(is.null(cl))
          stop("cluster object 'cl' is empty!")
        thisCall[[1]] <- quote(clusterMap)
        thisCall[["cl"]] <- cl
        thisCall[["fun"]] <- thisCall[["FUN"]] 
        thisCall[["FUN"]] <- NULL
        thisCall[["SIMPLIFY"]] <- TRUE
     }else {
      thisCall[[1]] <- quote(mapply)  #select loop mode
  
     }
    
    flist <- eval(thisCall)

    # Handles the case that 'flist' is a list of lists.
    #   The outer lists correspond to the split by pData factors.
    #   The inner lists contain the actual gates.
    #     The order do not necessarily match up with sampleNames()
    # Unforunately, we cannot simply use 'unlist' because the list element names
    # are mangled.
    
    if (all(sapply(flist, is.list))) {
      flist <- do.call(c, unname(flist))
    }
    #check failed sample 
    #eventually we want to handle this properly (like inserting dummy gates)
    #in order for the other samples proceed the gating
    failed <- sapply(flist, function(i)extends(class(i), "character"))
    if(any(failed)){
      print(flist[failed])
      stop("some samples failed!")
      
    }
    
    #this is flowClust-specific operation, which
    # be abstracted out of this framework
    if (extends(class(flist[[1]]), "fcFilter")) {
      flist <- fcFilterList(flist)
    }
    
    
    
    
    if(length(popAlias) == 1){
      #when Alias is meta character, then pass NULL
      # to add method which uses filterId slot to name the populations
      if(popAlias == "*")
        popAlias <- NULL  
    }
    
    gs_node_id <- add(y, flist, parent = parent, name = popAlias)
    
    for(this_gs_id in getNodes(y[[1]])[gs_node_id])
      invisible(recompute(y, this_gs_id, alwaysLoadData = TRUE))
    
    message("done.")
    
  }else{
    
    message("Skip gating! Population '", paste(popAlias, collapse = ","), "' already exists.")
    flist <- NULL
  }
    
  
  if (plot) {
    print(plotGate(y, gs_node_id, xbin = xbin, pos = c(0.5, 0.8)))
  }
  
  flist
}

#' apply a \code{boolMethod} to the \code{GatingSet}
#' 
#' @param x \code{boolMethod}
#' @inheritParams .gating_boolMethod
#' @param ... other arguments
#' @aliases
#' gating,boolMethod,GatingSet-method
#' gating,boolMethod,GatingSetList-method
setMethod("gating", signature = c("boolMethod", "GatingSet"),
    definition = function(x, y, ...) {
      .gating_boolMethod(x,y,...)      
    })
setMethod("gating", signature = c("boolMethod", "GatingSetList"),
    definition = function(x, y, ...) {
      .gating_boolMethod(x,y,...)      
    })

#' internal function (gating_boolMethod)
#' 
#'  @param y \code{GatingSet}
#'  @param gtPop a \code{gtPopulation} object that contains the information of the cell population that is going to be generated by this gating method.
#'  @param  parent \code{character} specifying the parent node within \code{GatingSet} to which the new popoulation is to be attached.
.gating_boolMethod <- function(x, y, gtPop, parent, ...) {
  
  args <- parameters(x)[[1]]
  gm <- paste0(".", names(x))
  popAlias <- alias(gtPop)
  popName <- names(gtPop)
  popId <- gtPop@id
  
  gs_nodes <- basename(getChildren(y[[1]], parent))
  tNodes <- deparse(args)
  if (!(popAlias %in% gs_nodes)) {
    message(popAlias, " gating...")
    bf <- eval(substitute(booleanFilter(x), list(x = args)))
    bf@filterId <- tNodes
    invisible(gs_node_id <- add(y, bf, parent = parent, name = popAlias))
    invisible(recompute(y, getNodes(y[[1]])[gs_node_id]))

    message("done.")
  } else {
    message("Skip gating! Population '", popAlias, "' already exists.")
  }
  
  # gs_node_id
  NULL
}

#' apply a \code{polyFunctions} gating method to the \code{GatingSet}
#' 
#' It generates a batch of \code{boolMethod}s based on the expression defined in \code{polyFunctions} objects.
#' It is a convenience way to generate different boolean combinations of cytokine gates. 
#' 
#' @param x \code{polyFunctions}
#' @inheritParams .gating_polyFunctions
#' @param ... other arguments
#' @aliases
#' gating,polyFunctions,GatingSet-method
#' gating,polyFunctions,GatingSetList-method
setMethod("gating", signature = c("polyFunctions", "GatingSet"),
    definition = function(x, y, ...) {
      .gating_polyFunctions(x,y,...)      
    })
setMethod("gating", signature = c("polyFunctions", "GatingSetList"),
    definition = function(x, y, ...) {
      .gating_polyFunctions(x,y,...)      
    })

#' internal function (gating_polyFunctions)
#' 
#'  @param y \code{GatingSet}
#'  @param gtPop a \code{gtPopulation} object that contains the information of the cell population that is going to be generated by this gating method.
#'  @param  parent \code{character} specifying the parent node within \code{GatingSet} to which the new popoulation is to be attached.
#' @importFrom gtools permutations 
.gating_polyFunctions <- function(x, y, gtPop, parent, ...) {
  
  refNodes <- x@refNodes
  popAlias <- alias(gtPop)
  message("Population '", paste(popAlias, collapse = ","), "'")
  
  nMarkers <- length(refNodes)

  ## all the comibnations of A & B & C
  opList <- permutations(n = 1, r = nMarkers - 1, c("&"), repeats.allowed = TRUE)
  isNotList <- permutations(n = 2, r = nMarkers, c("!", ""), repeats.allowed = TRUE)
  polyExprsList <- apply(opList, 1, function(curOps) {
    apply(isNotList, 1, function(curIsNot) {
      polyExprs <- curIsNot
      polyExprs[-1] <- paste0(curOps, curIsNot[-1])
      
      paste(paste0(polyExprs, refNodes), collapse = "")
    })
  })
  polyExprsList <- as.vector(polyExprsList)
  
  gs_nodes <- basename(getChildren(y[[1]], parent))
  # actual gating
  lapply(polyExprsList, function(polyExpr) {
    
    #replace the slash with colon 
    #since forward slash is reserved for gating path
    if(grepl("/",polyExpr)){
      old_name <- polyExpr
      new_name <- gsub("/",":",polyExpr)
      warning(old_name, " is replaced with ", new_name)
    }else
      new_name <- polyExpr
#    browser()
    
    isExist <- new_name %in% gs_nodes
    if (!isExist) {
      message("adding ", new_name, " ...")

      bf <- char2booleanFilter(polyExpr)

      invisible(gs_node_id <- .addGate_fast(y, bf, parent = parent, name = polyExpr))
      
  
    } else {
      message("Skip!Population '", new_name, "' already exists.")
    }        
  })
  #to reduce overhead,compute from parent node once instead of do it multiple times for each individual new bool gate
    
  invisible(recompute(y, parent))
  message("done.")
  
  list()
}
#' fast version of add gates to gatingset (bypassing some R checks)
.addGate_fast <- function(gs, filter, name = NULL, parent = NULL, negated = FALSE){
  
  
  
  
  #preprocess filter
  filterObj <- flowWorkspace:::filterObject(filter)
#  browser()
  if(is.null(name))
    name<-filterObj$filterId
  #replace the slash with colon 
  #since forward slash is reserved for gating path
  if(grepl("/",name)){
    old_name <- name
    name <- gsub("/",":",name)
    warning(old_name, " is replaced with ", name)
  }
  
  
  gh<-gs[[1]]
  ##get node ID
  if(is.null(parent))
    pid<-1
  else
  {
    if(is.numeric(parent))
      pid <- parent
    else
      pid <- flowWorkspace:::.getNodeInd(gh,parent)
  }
  filterObj$negated<-negated
  
  
  if(class(gs) == "GatingSetList"){
    nodeIDs <- lapply(gs, function(thisGS){
                        samples <- sampleNames(thisGS)
                        lapply(samples,function(sample){
                              
                                nodeID <- .Call("R_addGate",thisGS@pointer,sample,filterObj,as.integer(pid-1),name)
                                nodeID+1
                              })
                      }, level = 1)
    nodeIDs <- unlist(nodeIDs)
    
  }else{
    samples <- sampleNames(gs)
    nodeIDs<-lapply(samples,function(sample){
          
          nodeID <- .Call("R_addGate",gs@pointer,sample,filterObj,as.integer(pid-1),name)
          nodeID+1
        })  
  }
  
  
  nodeID<-nodeIDs[[1]]
  
  if(!all(sapply(nodeIDs[-1],function(x)identical(x,nodeID))))
    stop("nodeID are not identical across samples!")
  nodeID
}

#' apply a \code{refGate} to the \code{GatingSet}
#' 
#' @param x \code{refGate}
#' @inheritParams .gating_refGate
#' @param ... other arguments
#' 
#' @aliases
#' gating,refGate,GatingSet-method
#' gating,refGate,GatingSetList-method
#' gating,dummyMethod,GatingSet-method
#' gating,dummyMethod,GatingSetList-method
setMethod("gating", signature = c("refGate", "GatingSet"),
    definition = function(x, y, ...) {
      .gating_refGate(x, y, ...)
    })
setMethod("gating", signature = c("refGate", "GatingSetList"),
    definition = function(x, y, ...) {
      .gating_refGate(x, y, ...)
    })

setMethod("gating", signature = c("dummyMethod", "GatingSet"),
    definition = function(x, y, ...) {
      #do nothing
    })

setMethod("gating", signature = c("dummyMethod", "GatingSetList"),
    definition = function(x, y, ...) {
      #do nothing
    })

#' internal function (gating_refGate)
#' 
#'  @param y \code{GatingSet}
#'  @param gtPop a \code{gtPopulation} object that contains the information of the cell population that is going to be generated by this gating method.
#'  @param  parent \code{character} specifying the parent node within \code{GatingSet} to which the new popoulation is to be attached.
.gating_refGate <- function(x, y, gtPop, parent, plot = FALSE, xbin = 32,
            ...) {
#  negated <- FALSE
  refNodes <- x@refNodes
  popAlias <- alias(gtPop)
  popName <- names(gtPop)
  dims <- dims(x)
  xChannel <- dims[["xChannel"]]
  yChannel <- dims[["yChannel"]]
  
  gs_nodes <- basename(getChildren(y[[1]], parent))
  if (length(gs_nodes) == 0 || !popAlias %in% gs_nodes) {
    
    message("Population '", paste(popAlias, collapse = ","), "'")
    if (length(refNodes) > 2) {
      stop("Not sure how to construct gate from more than 2 reference nodes!")
    }
    
    fr <- getData(y[[1]])
    
    flist <- flowWorkspace::lapply(y, function(gh) {
          
       glist <- lapply(refNodes, function(refNode) {
#             browser()
          #match node by base name
          node_names <- getNodes(gh, showHidden = TRUE, path = 1, prefix = "auto")
          toMatch <- gsub("\\+", "\\\\\\+", refNode)
          toMatch <- paste0("^",toMatch,"$")
          node_ind <- grep(toMatch, node_names)
         if (length(node_ind) == 0) {
            #if no match to base name then match to path
            node_paths <- getNodes(gh, showHidden = TRUE)
            toMatch <- gsub("\\+", "\\\\+", refNode)
            toMatch <- paste(toMatch, "$", sep = "")
            node_ind <- grep(toMatch, node_paths)
            if (length(node_ind) == 0) {
            stop(refNode, " not found in gating set!")
            } else if (length(node_ind) > 1) {
            stop("Multiple ", refNode, " found in gating set!")
            }
          }else if(length(node_ind)>1)
              stop("Multiple ", refNode, " found in gating set!")
          
          getGate(gh, node_ind)
        })

      # standardize the names for the gate parameters and dims
      gate_params <- unlist(lapply(glist, function(g) {
        cur_param <- parameters(g)
        getChannelMarker(fr, cur_param)["name"]
      }))

      if(length(glist)==1){
        #1d ref gate
        dims <- dims[!is.na(dims)]
        nDims <- length(dims)
        
        pos_token <- "[\\+]"
        neg_token <- "[\\-]"
        pop_name_pat <- "[^\\+-]+"
        pos_pop_pat <- paste(pop_name_pat, pos_token, sep = "")
        neg_pop_pat <- paste(pop_name_pat, neg_token, sep = "")
        
        if(nDims==2){
          #set negated flag of outer scope when necessary
#          if (grepl(neg_pop_pat,popName)&&!negated) {
#            negated <<- TRUE
#          }
          #before flowCore and flowViz support the negated filter
          #we use refGate+boolGate in csv template as the workaround
          if (grepl(neg_pop_pat,popName)) {
            stop("negated 2d gate is not supported yet!")
          }
          #pass the gate as it is 
          glist[[1]]
        }else{
          dim_params <-  getChannelMarker(fr, dims)["name"]
          y_g <- glist[[1]]               
          y_coord <- c(y_g@min, y_g@max)
          cut.y <- y_coord[!is.infinite(y_coord)]
          
          
          if (grepl(pos_pop_pat,popName)) {
            #handle all infinite coordinates
            if(length(cut.y) == 0)
              cut.y <- -Inf
            gate_coordinates <- list(c(cut.y, Inf))
          } else if(grepl(neg_pop_pat,popName)){
            if(length(cut.y) == 0)
              cut.y <- Inf
            gate_coordinates <- list(c(-Inf, cut.y))
          }else{
            stop("unknown population pattern, ",popName)
          }
          names(gate_coordinates) <- as.character(dim_params)
          
          rectangleGate(gate_coordinates)  
        }
        
      }else{
          #2d quad gate
          dim_params <- unlist(lapply(dims, function(dim) {
                    getChannelMarker(fr, dim)["name"]
                  }))
          
          # match the gate param to dims to find gates for x, y dimensions
          x_g <- glist[[match(dim_params[1], gate_params)]]
          y_g <- glist[[match(dim_params[2], gate_params)]]
          
          # pick the non-infinite coordinate as the cut points
          x_coord <- c(x_g@min, x_g@max)
          y_coord <- c(y_g@min, y_g@max)
          cut.x <- x_coord[!is.infinite(x_coord)]
          cut.y <- y_coord[!is.infinite(y_coord)]
          
          # In order, the following vector has the patterns:
          # 1. top left (-+)
          # 2. top right (++)
          # 3. bottom right (+-)
          # 4. bottom left (--)
          quadPatterns <- c(".+-.+\\+$", ".+\\+.+\\+$", ".+\\+.+-$", ".+-.+-$")
          
          # check if popname is give as Y[*]X[*]
          YX_pattern <- paste0(dims["yChannel"], ".+", dims["xChannel"], ".+")
          XY_pattern <- paste0(dims["xChannel"], ".+", dims["yChannel"], ".+")
          
          # do the flipping if YX
          if (grepl(YX_pattern, popName)) {
            pos <- regexpr(dims["xChannel"], popName)
            xterm <- substring(popName, pos, nchar(popName))
            yterm <- substring(popName, 1, pos - 1)
            toMatch <- paste(xterm, yterm, sep = "")
          } else if (grepl(XY_pattern, popName)) {
            toMatch <- popName  #keep as it is if XY
          }
          else {
            stop("X,Y axis do not match between 'dims'(", paste(dims, collapse = ","), 
                ") and 'pop'(", popName, ")")
          }
          quadInd <- which(unlist(lapply(quadPatterns, grepl, toMatch)))
          
          # construct rectangleGate from reference cuts
          if (quadInd == 1) {
            #handle all infinite coordinates
            if(length(cut.x) == 0)
              cut.x <- Inf
            if(length(cut.y) == 0)
              cut.y <- -Inf
            coord <- list(c(-Inf, cut.x), c(cut.y, Inf))
          } else if (quadInd == 2) {
            #handle all infinite coordinates
            if(length(cut.x) == 0)
              cut.x <- -Inf
            if(length(cut.y) == 0)
              cut.y <- -Inf
            coord <- list(c(cut.x, Inf), c(cut.y, Inf))
          } else if (quadInd == 3) {
            #handle all infinite coordinates
            if(length(cut.x) == 0)
              cut.x <- -Inf
            if(length(cut.y) == 0)
              cut.y <- Inf
            coord <- list(c(cut.x, Inf), c(-Inf, cut.y))
          } else if (quadInd == 4) {
            #handle all infinite coordinates
            if(length(cut.x) == 0)
              cut.x <- Inf
            if(length(cut.y) == 0)
              cut.y <- Inf
            coord <- list(c(-Inf, cut.x), c(-Inf, cut.y))
          } else stop("Pop names does not match to any quadrant pattern!")
          
          names(coord) <- as.character(dim_params)
          rectangleGate(coord)
      }
      
    })
    
    flist <- filterList(flist)
    gs_node_id <- add(y, flist, parent = parent, name = popAlias)
    invisible(recompute(y, getNodes(y[[1]])[gs_node_id], alwaysLoadData = TRUE))
    
    if (plot) {
      print(plotGate(y, getNodes(y[[1]])[gs_node_id], xbin = xbin, pos = c(0.5, 0.8)))

    }
  } else {
    message("Skip gating! Population '", popAlias, "' already exists.")
    flist <- NULL
  }

  message("done.")
  flist
}

